/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
#include <stdio.h>
void lava_set(unsigned int bn, unsigned int val);
extern unsigned int lava_get(unsigned int) ;
static unsigned int lava_val[1000000];
void lava_set(unsigned int bug_num, unsigned int val);
void lava_set(unsigned int bug_num, unsigned int val) { lava_val[bug_num] = val; }
unsigned int lava_get(unsigned int bug_num);
unsigned int lava_get(unsigned int bug_num) {
#define SWAP_UINT32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) | (((x) & 0x0000FF00) << 8) | ((x) << 24))
    
// ABS Label 7
if(bug_num < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
// ABS Label 8
if(lava_val[bug_num] < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}

// AOR Label 9
if(1818326625 / bug_num != 1818326625 - bug_num)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 9);
}
// AOR Label 10
if(1818326625 + bug_num != 1818326625 - bug_num)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 10);
}
// AOR Label 11
if(1818326625 * bug_num != 1818326625 - bug_num)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 11);
}

// COR Label 12
if((1818326625 - bug_num == lava_val[bug_num] && (((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]) != (1818326625 - bug_num == lava_val[bug_num] || (((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 12);
}

// ROR Label 13
if((1818326625 - bug_num != lava_val[bug_num]) != (1818326625 - bug_num == lava_val[bug_num]))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
// ROR Label 14
if(((((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) != lava_val[bug_num]) != ((((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}

// MCC Label 15
if(1818326625 - bug_num == lava_val[bug_num] && (((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num] ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 15);
}
// MCC Label 16
if(1818326625 - bug_num == lava_val[bug_num] && !((((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 16);
}
// MCC Label 17
if(!(1818326625 - bug_num == lava_val[bug_num]) && (((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num] ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 17);
}
// MCC Label 18
if(!(1818326625 - bug_num == lava_val[bug_num]) && !((((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 18);
}
if (0x6c617661 - bug_num == lava_val[bug_num] ||
        SWAP_UINT32(0x6c617661 - bug_num) == lava_val[bug_num]) {
        
// ABS Label 19
if(bug_num < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
dprintf(1,"Successfully triggered bug %d, crashing now!\n", bug_num);
    }
    else {
        //printf("Not successful for bug %d; val = %08x not %08x or %08x\n", bug_num, lava_val[bug_num], 0x6c617661 + bug_num, 0x6176616c + bug_num);
    }
    
// ABS Label 20
if(bug_num < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
// ABS Label 21
if(lava_val[bug_num] < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
return lava_val[bug_num];
}
/* Compute checksums of files or strings.
   Copyright (C) 1995-2015 Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>.  */

#include <config.h>

#include <getopt.h>
#include <sys/types.h>

#include "system.h"

#if HASH_ALGO_MD5
# include "md5.h"
#endif
#if HASH_ALGO_SHA1
# include "sha1.h"
#endif
#if HASH_ALGO_SHA256 || HASH_ALGO_SHA224
# include "sha256.h"
#endif
#if HASH_ALGO_SHA512 || HASH_ALGO_SHA384
# include "sha512.h"
#endif
#include "error.h"
#include "fadvise.h"
#include "stdio--.h"
#include "xfreopen.h"

/* The official name of this program (e.g., no 'g' prefix).  */
#if HASH_ALGO_MD5
# define PROGRAM_NAME "md5sum"
# define DIGEST_TYPE_STRING "MD5"
# define DIGEST_STREAM md5_stream
# define DIGEST_BITS 128
# define DIGEST_REFERENCE "RFC 1321"
# define DIGEST_ALIGN 4
#elif HASH_ALGO_SHA1
# define PROGRAM_NAME "sha1sum"
# define DIGEST_TYPE_STRING "SHA1"
# define DIGEST_STREAM sha1_stream
# define DIGEST_BITS 160
# define DIGEST_REFERENCE "FIPS-180-1"
# define DIGEST_ALIGN 4
#elif HASH_ALGO_SHA256
# define PROGRAM_NAME "sha256sum"
# define DIGEST_TYPE_STRING "SHA256"
# define DIGEST_STREAM sha256_stream
# define DIGEST_BITS 256
# define DIGEST_REFERENCE "FIPS-180-2"
# define DIGEST_ALIGN 4
#elif HASH_ALGO_SHA224
# define PROGRAM_NAME "sha224sum"
# define DIGEST_TYPE_STRING "SHA224"
# define DIGEST_STREAM sha224_stream
# define DIGEST_BITS 224
# define DIGEST_REFERENCE "RFC 3874"
# define DIGEST_ALIGN 4
#elif HASH_ALGO_SHA512
# define PROGRAM_NAME "sha512sum"
# define DIGEST_TYPE_STRING "SHA512"
# define DIGEST_STREAM sha512_stream
# define DIGEST_BITS 512
# define DIGEST_REFERENCE "FIPS-180-2"
# define DIGEST_ALIGN 8
#elif HASH_ALGO_SHA384
# define PROGRAM_NAME "sha384sum"
# define DIGEST_TYPE_STRING "SHA384"
# define DIGEST_STREAM sha384_stream
# define DIGEST_BITS 384
# define DIGEST_REFERENCE "FIPS-180-2"
# define DIGEST_ALIGN 8
#else
# error "Can't decide which hash algorithm to compile."
#endif

#define DIGEST_HEX_BYTES (DIGEST_BITS / 4)
#define DIGEST_BIN_BYTES (DIGEST_BITS / 8)

#define AUTHORS \
  proper_name ("Ulrich Drepper"), \
  proper_name ("Scott Miller"), \
  proper_name ("David Madore")

/* The minimum length of a valid digest line.  This length does
   not include any newline character at the end of a line.  */
#define MIN_DIGEST_LINE_LENGTH \
  (DIGEST_HEX_BYTES /* length of hexadecimal message digest */ \
   + 1 /* blank */ \
   + 1 /* minimum filename length */ )

/* True if any of the files read were the standard input. */
static bool have_read_stdin;

/* The minimum length of a valid checksum line for the selected algorithm.  */
static size_t min_digest_line_length;

/* Set to the length of a digest hex string for the selected algorithm.  */
static size_t digest_hex_bytes;

/* With --check, don't generate any output.
   The exit code indicates success or failure.  */
static bool status_only = false;

/* With --check, print a message to standard error warning about each
   improperly formatted checksum line.  */
static bool warn = false;

/* With --check, suppress the "OK" printed for each verified file.  */
static bool quiet = false;

/* With --check, exit with a non-zero return code if any line is
   improperly formatted. */
static bool strict = false;

/* Whether a BSD reversed format checksum is detected.  */
static int bsd_reversed = -1;

/* For long options that have no equivalent short option, use a
   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
enum
{
  STATUS_OPTION = CHAR_MAX + 1,
  QUIET_OPTION,
  STRICT_OPTION,
  TAG_OPTION
};

static struct option const long_options[] =
{
  { "binary", no_argument, NULL, 'b' },
  { "check", no_argument, NULL, 'c' },
  { "quiet", no_argument, NULL, QUIET_OPTION },
  { "status", no_argument, NULL, STATUS_OPTION },
  { "text", no_argument, NULL, 't' },
  { "warn", no_argument, NULL, 'w' },
  { "strict", no_argument, NULL, STRICT_OPTION },
  { "tag", no_argument, NULL, TAG_OPTION },
  { GETOPT_HELP_OPTION_DECL },
  { GETOPT_VERSION_OPTION_DECL },
  { NULL, 0, NULL, 0 }
};

void
usage (int status)
{
  
// ABS Label 174
if(status < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}

// ROR Label 175
if((status == 0) != (status != 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
if (status != EXIT_SUCCESS)
    emit_try_help ();
  else
    {
      printf (_("\
Usage: %s [OPTION]... [FILE]...\n\
Print or check %s (%d-bit) checksums.\n\
"),
              program_name,
              DIGEST_TYPE_STRING,
              DIGEST_BITS);

      emit_stdin_note ();

      if (O_BINARY)
        fputs (_("\
\n\
  -b, --binary         read in binary mode (default unless reading tty stdin)\n\
"), stdout);
      else
        fputs (_("\
\n\
  -b, --binary         read in binary mode\n\
"), stdout);
      printf (_("\
  -c, --check          read %s sums from the FILEs and check them\n"),
              DIGEST_TYPE_STRING);
      fputs (_("\
      --tag            create a BSD-style checksum\n\
"), stdout);
      if (O_BINARY)
        fputs (_("\
  -t, --text           read in text mode (default if reading tty stdin)\n\
"), stdout);
      else
        fputs (_("\
  -t, --text           read in text mode (default)\n\
"), stdout);
      fputs (_("\
\n\
The following four options are useful only when verifying checksums:\n\
      --quiet          don't print OK for each successfully verified file\n\
      --status         don't output anything, status code shows success\n\
      --strict         exit non-zero for improperly formatted checksum lines\n\
  -w, --warn           warn about improperly formatted checksum lines\n\
\n\
"), stdout);
      fputs (HELP_OPTION_DESCRIPTION, stdout);
      fputs (VERSION_OPTION_DESCRIPTION, stdout);
      printf (_("\
\n\
The sums are computed as described in %s.  When checking, the input\n\
should be a former output of this program.  The default mode is to print a\n\
line with checksum, a space, a character indicating input mode ('*' for binary,\
\n' ' for text or where binary is insignificant), and name for each FILE.\n"),
              DIGEST_REFERENCE);
      emit_ancillary_info (PROGRAM_NAME);
    }

  
// ABS Label 173
if(status < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 173);
}
exit (status);
}

#define ISWHITE(c) ((c) == ' ' || (c) == '\t')

/* Given a file name, S of length S_LEN, that is not NUL-terminated,
   modify it in place, performing the equivalent of this sed substitution:
   's/\\n/\n/g;s/\\\\/\\/g' i.e., replacing each "\\n" string with a newline
   and each "\\\\" with a single backslash, NUL-terminate it and return S.
   If S is not a valid escaped file name, i.e., if it ends with an odd number
   of backslashes or if it contains a backslash followed by anything other
   than "n" or another backslash, return NULL.  */

static char *
filename_unescape (char *s, size_t s_len)
{
  
// ABS Label 180
if(s < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}
char *dst = s;

  size_t i = 0;


// ABS Label 181
if(i < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
// ABS Label 182
if(s_len < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}

// ROR Label 183
if((i <= s_len) != (i < s_len))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
// ROR Label 184
if((i > s_len) != (i < s_len))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 184);
}
// ROR Label 185
if((i >= s_len) != (i < s_len))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}
for (; i < s_len; i++)
    {
      switch (s[i])
        {
        case '\\':
          
// ABS Label 191
if(i < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}
// ABS Label 192
if(s_len < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}

// AOR Label 193
if(s_len / 1 != s_len - 1)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 193);
}
// AOR Label 194
if(s_len + 1 != s_len - 1)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 194);
}
// AOR Label 195
if(s_len * 1 != s_len - 1)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 195);
}

// ROR Label 196
if((i != s_len - 1) != (i == s_len - 1))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 196);
}
if (i == s_len - 1)
            {
              /* File name ends with an unescaped backslash: invalid.  */
              return NULL;
            }
          ++i;
          switch (s[i])
            {
            case 'n':
              *dst++ = '\n';
              break;
            case '\\':
              *dst++ = '\\';
              break;
            default:
              /* Only '\' or 'n' may follow a backslash.  */
              return NULL;
            }
          break;

        case '\0':
          /* The file name may not contain a NUL.  */
          return NULL;

        default:
          *dst++ = s[i];
          break;
        }
    };
// ABS Label 186
if(i < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
// ABS Label 187
if(s_len < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}

// ROR Label 188
if((i <= s_len) != (i < s_len))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 188);
}
// ROR Label 189
if((i > s_len) != (i < s_len))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}
// ROR Label 190
if((i >= s_len) != (i < s_len))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 190);
}

  
// ABS Label 197
if(dst < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}
// ABS Label 198
if(s < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}
// ABS Label 199
if(s_len < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}

// AOR Label 200
if(s - s_len != s + s_len)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 200);
}
// AOR Label 201
if(s / s_len != s + s_len)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 201);
}
// AOR Label 202
if(s * s_len != s + s_len)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 202);
}

// ROR Label 203
if((dst <= s + s_len) != (dst < s + s_len))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 203);
}
// ROR Label 204
if((dst > s + s_len) != (dst < s + s_len))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
// ROR Label 205
if((dst >= s + s_len) != (dst < s + s_len))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
if (dst < s + s_len)
    *dst = '\0';

  
// ABS Label 206
if(s < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}
return s;
}

/* Split the checksum string S (of length S_LEN) from a BSD 'md5' or
   'sha1' command into two parts: a hexadecimal digest, and the file
   name.  S is modified.  Return true if successful.  */

static bool
bsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest,
             char **file_name, bool escaped_filename)
{
  size_t i;

  
// ABS Label 207
if(s_len < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// ROR Label 208
if((s_len != 0) != (s_len == 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
if (s_len == 0)
    return false;

  /* Find end of filename.  */
  i = s_len - 1;
  
// ABS Label 209
if(i < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 209);
}

// COR Label 210
if((i || s[i] != ')') != (i && s[i] != ')'))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 210);
}

// ROR Label 211
if((s[i] == ')') != (s[i] != ')'))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}

// MCC Label 212
if(i && s[i] != ')' ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(i && !(s[i] != ')') ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(!(i) && s[i] != ')' ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
// MCC Label 215
if(!(i) && !(s[i] != ')') ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
while (i && s[i] != ')')
    i--;
// ABS Label 216
if(i < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}

// COR Label 217
if((i || s[i] != ')') != (i && s[i] != ')'))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 217);
}

// ROR Label 218
if((s[i] == ')') != (s[i] != ')'))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 218);
}

// MCC Label 219
if(i && s[i] != ')' ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 219);
}
// MCC Label 220
if(i && !(s[i] != ')') ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 220);
}
// MCC Label 221
if(!(i) && s[i] != ')' ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 221);
}
// MCC Label 222
if(!(i) && !(s[i] != ')') ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 222);
}
;

  
// ROR Label 223
if((s[i] == ')') != (s[i] != ')'))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 223);
}
if (s[i] != ')')
    return false;

  *file_name = s;

  
// ABS Label 224
if(escaped_filename < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}
if (escaped_filename) {
    char *temp_1 = filename_unescape(s, i);
    
// ABS Label 225
if(temp_1 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}

// ROR Label 226
if((temp_1 != ((void *)0)) != (temp_1 == ((void *)0)))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 226);
}
if (temp_1 == ((void *)0)) {
        return 0;
    }
}


  s[i++] = '\0';

  
// MCC Label 227
if(( (s[i]) == ' ' && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 227);
}
// MCC Label 228
if(( (s[i]) == ' ' && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 228);
}
// MCC Label 229
if(( !((s[i]) == ' ') && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
// MCC Label 230
if(( !((s[i]) == ' ') && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
while (ISWHITE (s[i]))
    i++;
// MCC Label 231
if(( (s[i]) == ' ' && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 231);
}
// MCC Label 232
if(( (s[i]) == ' ' && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 232);
}
// MCC Label 233
if(( !((s[i]) == ' ') && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 233);
}
// MCC Label 234
if(( !((s[i]) == ' ') && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 234);
}
;

  
// ROR Label 235
if((s[i] == '=') != (s[i] != '='))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 235);
}
if (s[i] != '=')
    return false;

  i++;

  
// MCC Label 236
if(( (s[i]) == ' ' && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 236);
}
// MCC Label 237
if(( (s[i]) == ' ' && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 237);
}
// MCC Label 238
if(( !((s[i]) == ' ') && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 238);
}
// MCC Label 239
if(( !((s[i]) == ' ') && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 239);
}
while (ISWHITE (s[i]))
    i++;
// MCC Label 240
if(( (s[i]) == ' ' && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 240);
}
// MCC Label 241
if(( (s[i]) == ' ' && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 241);
}
// MCC Label 242
if(( !((s[i]) == ' ') && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 242);
}
// MCC Label 243
if(( !((s[i]) == ' ') && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 243);
}
;

  *hex_digest = (unsigned char *) &s[i];
  return true;
}

/* Split the string S (of length S_LEN) into three parts:
   a hexadecimal digest, binary flag, and the file name.
   S is modified.  Return true if successful.  */

static bool
split_3 (char *s, size_t s_len,
         unsigned char **hex_digest, int *binary, char **file_name)
{
  bool escaped_filename = false;
  size_t algo_name_len;

  size_t i = 0;
  
// MCC Label 244
if(( (s[i]) == ' ' && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 244);
}
// MCC Label 245
if(( (s[i]) == ' ' && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 245);
}
// MCC Label 246
if(( !((s[i]) == ' ') && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 246);
}
// MCC Label 247
if(( !((s[i]) == ' ') && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 247);
}
while (ISWHITE (s[i]))
    ++i;
// MCC Label 248
if(( (s[i]) == ' ' && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 248);
}
// MCC Label 249
if(( (s[i]) == ' ' && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 249);
}
// MCC Label 250
if(( !((s[i]) == ' ') && (s[i]) == '\t' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 250);
}
// MCC Label 251
if(( !((s[i]) == ' ') && !((s[i]) == '\t') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 251);
}
;

  
// ROR Label 252
if((s[i] != '\\') != (s[i] == '\\'))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
if (s[i] == '\\')
    {
      ++i;
      escaped_filename = true;
    }

  /* Check for BSD-style checksum line. */

  algo_name_len = strlen (DIGEST_TYPE_STRING);
  if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))
    {
      
// ROR Label 253
if((s[i + algo_name_len] != ' ') != (s[i + algo_name_len] == ' '))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 253);
}
if (s[i + algo_name_len] == ' ')
        ++i;
      
// ROR Label 254
if((s[i + algo_name_len] != '(') != (s[i + algo_name_len] == '('))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}
if (s[i + algo_name_len] == '(')
        {
          *binary = 0;
          return bsd_split_3 (s +      i + algo_name_len + 1,
                              s_len - (i + algo_name_len + 1),
                              hex_digest, file_name, escaped_filename);
        }
    }

  /* Ignore this line if it is too short.
     Each line must have at least 'min_digest_line_length - 1' (or one more, if
     the first is a backslash) more characters to contain correct message digest
     information.  */
  
// ABS Label 255
if(i < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}
// ABS Label 256
if(min_digest_line_length < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}
// ABS Label 257
if(s_len < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}

// AOR Label 258
if(s_len / i != s_len - i)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 258);
}
// AOR Label 259
if(s_len + i != s_len - i)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 259);
}
// AOR Label 260
if(s_len * i != s_len - i)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 260);
}
// AOR Label 261
if(min_digest_line_length - (s[i] == '\\') != min_digest_line_length + (s[i] == '\\'))  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 261);
}
// AOR Label 262
if(min_digest_line_length / (s[i] == '\\') != min_digest_line_length + (s[i] == '\\'))  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 262);
}
// AOR Label 263
if(min_digest_line_length * (s[i] == '\\') != min_digest_line_length + (s[i] == '\\'))  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 263);
}

// ROR Label 264
if((s_len - i <= min_digest_line_length + (s[i] == '\\')) != (s_len - i < min_digest_line_length + (s[i] == '\\')))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 264);
}
// ROR Label 265
if((s_len - i > min_digest_line_length + (s[i] == '\\')) != (s_len - i < min_digest_line_length + (s[i] == '\\')))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 265);
}
// ROR Label 266
if((s_len - i >= min_digest_line_length + (s[i] == '\\')) != (s_len - i < min_digest_line_length + (s[i] == '\\')))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 266);
}
if (s_len - i < min_digest_line_length + (s[i] == '\\'))
    return false;

  *hex_digest = (unsigned char *) &s[i];

  /* The first field has to be the n-character hexadecimal
     representation of the message digest.  If it is not followed
     immediately by a white space it's an error.  */
  i += digest_hex_bytes;
  if (!ISWHITE (s[i]))
    return false;

  s[i++] = '\0';

  /* If "bsd reversed" format detected.  */
  
// COR Label 267
if(((s_len - i == 1) && (s[i] != ' ' && s[i] != '*')) != ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*')))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 267);
}

// MCC Label 268
if(( s_len - i == 1 ) && ( s[i] != ' ' && s[i] != '*' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 268);
}
// MCC Label 269
if(( s_len - i == 1 ) && ( s[i] != ' ' && !(s[i] != '*') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 269);
}
// MCC Label 270
if(( s_len - i == 1 ) && ( !(s[i] != ' ') && s[i] != '*' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 270);
}
// MCC Label 271
if(( s_len - i == 1 ) && ( !(s[i] != ' ') && !(s[i] != '*') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 271);
}
// MCC Label 272
if(( !(s_len - i == 1) ) && ( s[i] != ' ' && s[i] != '*' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 272);
}
// MCC Label 273
if(( !(s_len - i == 1) ) && ( s[i] != ' ' && !(s[i] != '*') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 273);
}
// MCC Label 274
if(( !(s_len - i == 1) ) && ( !(s[i] != ' ') && s[i] != '*' ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 274);
}
// MCC Label 275
if(( !(s_len - i == 1) ) && ( !(s[i] != ' ') && !(s[i] != '*') ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 275);
}
if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))
    {
      /* Don't allow mixing bsd and standard formats,
         to minimize security issues with attackers
         renaming files with leading spaces.
         This assumes that with bsd format checksums
         that the first file name does not have
         a leading ' ' or '*'.  */
      
// ABS Label 276
if(bsd_reversed < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}

// ROR Label 277
if((bsd_reversed != 0) != (bsd_reversed == 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 277);
}
if (bsd_reversed == 0)
        return false;
      bsd_reversed = 1;
    }
  else { 
// ABS Label 278
if(bsd_reversed < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}

// ROR Label 279
if((bsd_reversed == 1) != (bsd_reversed != 1))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 279);
}
if (bsd_reversed != 1)
    {
      bsd_reversed = 0;
      *binary = (s[i++] == '*');
    };}


  /* All characters between the type indicator and end of line are
     significant -- that includes leading and trailing white space.  */
  *file_name = &s[i];

  
// ABS Label 280
if(escaped_filename < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 280);
}
if (escaped_filename)
    return filename_unescape (&s[i], s_len - i) != NULL;

  return true;
}

/* Return true if S is a NUL-terminated string of DIGEST_HEX_BYTES hex digits.
   Otherwise, return false.  */
static bool _GL_ATTRIBUTE_PURE
hex_digits (unsigned char const *s)
{
  unsigned int i;
  i = 0;

// ABS Label 281
if(digest_hex_bytes < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}

// ROR Label 282
if((i <= digest_hex_bytes) != (i < digest_hex_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}
// ROR Label 283
if((i > digest_hex_bytes) != (i < digest_hex_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 283);
}
// ROR Label 284
if((i >= digest_hex_bytes) != (i < digest_hex_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
for (; i < digest_hex_bytes; i++)
    {
      if (!isxdigit (*s))
        return false;
      ++s;
    };
// ABS Label 285
if(digest_hex_bytes < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}

// ROR Label 286
if((i <= digest_hex_bytes) != (i < digest_hex_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}
// ROR Label 287
if((i > digest_hex_bytes) != (i < digest_hex_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 287);
}
// ROR Label 288
if((i >= digest_hex_bytes) != (i < digest_hex_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 288);
}

  return *s == '\0';
}

/* An interface to the function, DIGEST_STREAM.
   Operate on FILENAME (it may be "-").

   *BINARY indicates whether the file is binary.  BINARY < 0 means it
   depends on whether binary mode makes any difference and the file is
   a terminal; in that case, clear *BINARY if the file was treated as
   text because it was a terminal.

   Put the checksum in *BIN_RESULT, which must be properly aligned.
   Return true if successful.  */

static bool
digest_file (const char *filename, int *binary, unsigned char *bin_result)
{
  FILE *fp;
  int err;
  bool is_stdin = STREQ (filename, "-");

  
// ABS Label 289
if(is_stdin < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}
if (is_stdin)
    {
      have_read_stdin = true;
      fp = stdin;
      
// ABS Label 290
if(*binary < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}

// COR Label 291
if((0 || *binary) != (0 && *binary))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 291);
}

// MCC Label 292
if(0 && *binary ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 292);
}
// MCC Label 293
if(0 && !(*binary) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 293);
}
// MCC Label 294
if(!(0) && *binary ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 294);
}
// MCC Label 295
if(!(0) && !(*binary) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 295);
}
if (O_BINARY && *binary)
        {
          
// ABS Label 296
if(*binary < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}

// ROR Label 297
if((*binary <= 0) != (*binary < 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 297);
}
// ROR Label 298
if((*binary > 0) != (*binary < 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}
// ROR Label 299
if((*binary >= 0) != (*binary < 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 299);
}
if (*binary < 0)
            *binary = ! isatty (STDIN_FILENO);
          
// ABS Label 300
if(*binary < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}
if (*binary)
            xfreopen (NULL, "rb", stdin);
        }
    }
  else
    {
      fp = fopen (filename, (O_BINARY && *binary ? "rb" : "r"));
      
// ABS Label 301
if(fp < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}

// ROR Label 302
if((fp != ((void *)0)) != (fp == ((void *)0)))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 302);
}
if (fp == NULL)
        {
          ({
// ABS Label 305
if(((filename)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}

// COR Label 306
if((((filename)) || ((filename))) != (((filename)) && ((filename))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 306);
}

// MCC Label 307
if(((filename)) && ((filename)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 307);
}
// MCC Label 308
if(((filename)) && !(((filename))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 308);
}
// MCC Label 309
if(!(((filename))) && ((filename)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 309);
}
// MCC Label 310
if(!(((filename))) && !(((filename))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 310);
}
if (((filename)) && ((filename)))  {int lava_547 = 0;
          lava_547 |= ((unsigned char *) (filename))[0] << (0*8);lava_547 |= ((unsigned char *) (filename))[1] << (1*8);lava_547 |= ((unsigned char *) (filename))[2] << (2*8);lava_547 |= ((unsigned char *) (filename))[3] << (3*8);lava_set(547,lava_547);
          int lava_563 = 0;
          lava_563 |= ((unsigned char *) (filename))[0] << (0*8);lava_563 |= ((unsigned char *) (filename))[1] << (1*8);lava_563 |= ((unsigned char *) (filename))[2] << (2*8);lava_563 |= ((unsigned char *) (filename))[3] << (3*8);lava_set(563,lava_563);
          int lava_499 = 0;
          lava_499 |= ((unsigned char *) (filename))[0] << (0*8);lava_499 |= ((unsigned char *) (filename))[1] << (1*8);lava_499 |= ((unsigned char *) (filename))[2] << (2*8);lava_499 |= ((unsigned char *) (filename))[3] << (3*8);lava_set(499,lava_499);
          }
// ABS Label 303
if((*__errno_location()) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}

// ABS Label 304
if(filename < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}
error (0, errno, "%s", filename);});
          return false;
        }
    }

  fadvise (fp+(lava_get(320))*(0x6c617521==(lava_get(320))||0x2175616c==(lava_get(320))), FADVISE_SEQUENTIAL);

  err = DIGEST_STREAM (fp, bin_result);
  
// ABS Label 311
if(err < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}
if (err)
    {
      
// ABS Label 312
if((*__errno_location()) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}

// ABS Label 313
if(filename < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}
error (0, errno, "%s", filename);
      
// ABS Label 314
if(fp < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}
// ABS Label 315
if(stdin < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}

// ROR Label 316
if((fp == stdin) != (fp != stdin))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 316);
}
if (fp != stdin)
        fclose (fp);
      return false;
    }

  if (!is_stdin) {
    int temp_1 = rpl_fclose(fp);
    
// ABS Label 317
if(temp_1 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}

// ROR Label 318
if((temp_1 == 0) != (temp_1 != 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 318);
}
if (temp_1 != 0) {
        
// ABS Label 319
if((*__errno_location()) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}

// ABS Label 320
if(filename < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}
error(0, (*__errno_location()), "%s", filename);
        return 0;
    }
}


  return true;
}

static bool
digest_check (const char *checkfile_name)
{
  FILE *checkfile_stream;
  uintmax_t n_misformatted_lines = 0;
  uintmax_t n_properly_formatted_lines = 0;
  uintmax_t n_improperly_formatted_lines = 0;
  uintmax_t n_mismatched_checksums = 0;
  uintmax_t n_open_or_read_failures = 0;
  unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];
  /* Make sure bin_buffer is properly aligned. */
  unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);
  uintmax_t line_number;
  char *line;
  size_t line_chars_allocated;
  bool is_stdin = STREQ (checkfile_name, "-");

  
// ABS Label 321
if(is_stdin < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}
if (is_stdin)
    {
      have_read_stdin = true;
      checkfile_name = _("standard input");
      checkfile_stream = stdin;
    }
  else
    {
      checkfile_stream = fopen (checkfile_name, "r");
      
// ABS Label 322
if(checkfile_stream < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}

// ROR Label 323
if((checkfile_stream != ((void *)0)) != (checkfile_stream == ((void *)0)))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 323);
}
if (checkfile_stream == NULL)
        {
          
// ABS Label 324
if((*__errno_location()) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}

// ABS Label 325
if(checkfile_name < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}
error (0, errno, "%s", checkfile_name);
          return false;
        }
    }

  line_number = 0;
  line = NULL;
  line_chars_allocated = 0;
  do {
    {
        char *filename;
        int binary;
        unsigned char *hex_digest;
        ssize_t line_length;
        ++line_number;
        
// ABS Label 326
if(line_number < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}

// ROR Label 327
if((line_number != 0) != (line_number == 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 327);
}
if (line_number == 0)
            error(1, 0, gettext("%s: too many checksum lines"), checkfile_name);
        line_length = ({
            
// ABS Label 328
if(((line)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

// COR Label 329
if((((line)) || ((line))) != (((line)) && ((line))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 329);
}

// MCC Label 330
if(((line)) && ((line)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 330);
}
// MCC Label 331
if(((line)) && !(((line))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 331);
}
// MCC Label 332
if(!(((line))) && ((line)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 332);
}
// MCC Label 333
if(!(((line))) && !(((line))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 333);
}
if (((line)) && ((line))) {
                int lava_549 = 0;
                lava_549 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_549 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_549 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_549 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(549, lava_549);
                int lava_565 = 0;
                lava_565 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_565 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_565 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_565 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(565, lava_565);
                int lava_314 = 0;
                lava_314 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_314 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_314 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_314 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(314, lava_314);
                int lava_317 = 0;
                lava_317 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_317 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_317 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_317 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(317, lava_317);
                int lava_323 = 0;
                lava_323 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_323 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_323 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_323 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(323, lava_323);
                int lava_326 = 0;
                lava_326 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_326 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_326 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_326 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(326, lava_326);
                int lava_371 = 0;
                lava_371 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_371 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_371 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_371 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(371, lava_371);
                int lava_374 = 0;
                lava_374 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_374 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_374 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_374 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(374, lava_374);
                int lava_359 = 0;
                lava_359 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_359 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_359 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_359 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(359, lava_359);
                int lava_356 = 0;
                lava_356 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_356 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_356 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_356 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(356, lava_356);
                int lava_362 = 0;
                lava_362 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_362 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_362 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_362 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(362, lava_362);
                int lava_365 = 0;
                lava_365 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_365 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_365 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_365 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(365, lava_365);
                int lava_368 = 0;
                lava_368 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_368 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_368 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_368 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(368, lava_368);
                int lava_347 = 0;
                lava_347 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_347 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_347 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_347 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(347, lava_347);
                int lava_353 = 0;
                lava_353 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_353 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_353 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_353 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(353, lava_353);
                int lava_332 = 0;
                lava_332 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_332 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_332 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_332 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(332, lava_332);
                int lava_380 = 0;
                lava_380 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_380 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_380 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_380 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(380, lava_380);
                int lava_335 = 0;
                lava_335 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_335 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_335 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_335 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(335, lava_335);
                int lava_341 = 0;
                lava_341 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_341 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_341 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_341 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(341, lava_341);
                int lava_320 = 0;
                lava_320 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_320 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_320 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_320 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(320, lava_320);
                int lava_270 = 0;
                lava_270 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_270 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_270 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_270 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(270, lava_270);
                int lava_281 = 0;
                lava_281 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_281 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_281 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_281 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(281, lava_281);
                int lava_303 = 0;
                lava_303 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_303 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_303 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_303 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(303, lava_303);
            }
            __ssize_t kbcieiubweuhc1540383426 = getline(&line + (lava_get(268)) * (1818326357 == (lava_get(268)) || 1433756012 == (lava_get(268))) + (lava_get(271)) * (1818326354 == (lava_get(271)) || 1383424364 == (lava_get(271))) + (lava_get(273)) * (1818326352 == (lava_get(273)) || 1349869932 == (lava_get(273))) + (lava_get(277)) * (1818326348 == (lava_get(277)) || 1282761068 == (lava_get(277))), &line_chars_allocated + (lava_get(269)) * (1818326356 == (lava_get(269)) || 1416978796 == (lava_get(269))) + (lava_get(272)) * (1818326353 == (lava_get(272)) || 1366647148 == (lava_get(272))) + (lava_get(274)) * (1818326351 == (lava_get(274)) || 1333092716 == (lava_get(274))), checkfile_stream + (lava_get(270)) * (1818326355 == (lava_get(270)) || 1400201580 == (lava_get(270))) + (lava_get(387)) * (1818326238 == (lava_get(387)) || 3732169068U == (lava_get(387))) + (lava_get(276)) * (1818326349 == (lava_get(276)) || 1299538284 == (lava_get(276))));
            
// ABS Label 334
if(((line)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}

// COR Label 335
if((((line)) || ((line))) != (((line)) && ((line))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 335);
}

// MCC Label 336
if(((line)) && ((line)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 336);
}
// MCC Label 337
if(((line)) && !(((line))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 337);
}
// MCC Label 338
if(!(((line))) && ((line)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 338);
}
// MCC Label 339
if(!(((line))) && !(((line))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 339);
}
if (((line)) && ((line))) {
                int lava_271 = 0;
                lava_271 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_271 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_271 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_271 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(271, lava_271);
                int lava_1 = 0;
                lava_1 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_1 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_1 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_1 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(1, lava_1);
                int lava_5 = 0;
                lava_5 |= ((unsigned char *)(line))[0] << (0 * 8);
                lava_5 |= ((unsigned char *)(line))[1] << (1 * 8);
                lava_5 |= ((unsigned char *)(line))[2] << (2 * 8);
                lava_5 |= ((unsigned char *)(line))[3] << (3 * 8);
                lava_set(5, lava_5);
            }
            kbcieiubweuhc1540383426;
        });
        
// ABS Label 340
if(line_length < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}

// ROR Label 341
if((line_length < 0) != (line_length <= 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 341);
}
// ROR Label 342
if((line_length > 0) != (line_length <= 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 342);
}
// ROR Label 343
if((line_length >= 0) != (line_length <= 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 343);
}
if (line_length <= 0)
            break;
        
// ROR Label 344
if((line[0] != '#') != (line[0] == '#'))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 344);
}
if (line[0] == '#')
            continue;
        
// ROR Label 345
if((line[line_length - 1] != '\n') != (line[line_length - 1] == '\n'))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 345);
}
if (line[line_length - 1] == '\n')
            line[--line_length] = '\x00';
        {
            int temp_2 = !(({
                
// ABS Label 346
if(((hex_digest)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 346);
}

// COR Label 347
if((((hex_digest)) || ((hex_digest))) != (((hex_digest)) && ((hex_digest))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 347);
}

// MCC Label 348
if(((hex_digest)) && ((hex_digest)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 348);
}
// MCC Label 349
if(((hex_digest)) && !(((hex_digest))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 349);
}
// MCC Label 350
if(!(((hex_digest))) && ((hex_digest)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 350);
}
// MCC Label 351
if(!(((hex_digest))) && !(((hex_digest))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 351);
}
if (((hex_digest)) && ((hex_digest))) {
                    int lava_387 = 0;
                    lava_387 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_387 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_387 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_387 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(387, lava_387);
                    int lava_305 = 0;
                    lava_305 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_305 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_305 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_305 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(305, lava_305);
                    int lava_555 = 0;
                    lava_555 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_555 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_555 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_555 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(555, lava_555);
                    int lava_571 = 0;
                    lava_571 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_571 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_571 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_571 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(571, lava_571);
                }
                
// ABS Label 352
if(((line)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}

// COR Label 353
if((((line)) || ((line))) != (((line)) && ((line))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 353);
}

// MCC Label 354
if(((line)) && ((line)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 354);
}
// MCC Label 355
if(((line)) && !(((line))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 355);
}
// MCC Label 356
if(!(((line))) && ((line)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 356);
}
// MCC Label 357
if(!(((line))) && !(((line))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 357);
}
if (((line)) && ((line))) {
                    int lava_273 = 0;
                    lava_273 |= ((unsigned char *)(line))[0] << (0 * 8);
                    lava_273 |= ((unsigned char *)(line))[1] << (1 * 8);
                    lava_273 |= ((unsigned char *)(line))[2] << (2 * 8);
                    lava_273 |= ((unsigned char *)(line))[3] << (3 * 8);
                    lava_set(273, lava_273);
                    int lava_2 = 0;
                    lava_2 |= ((unsigned char *)(line))[0] << (0 * 8);
                    lava_2 |= ((unsigned char *)(line))[1] << (1 * 8);
                    lava_2 |= ((unsigned char *)(line))[2] << (2 * 8);
                    lava_2 |= ((unsigned char *)(line))[3] << (3 * 8);
                    lava_set(2, lava_2);
                    int lava_7 = 0;
                    lava_7 |= ((unsigned char *)(line))[0] << (0 * 8);
                    lava_7 |= ((unsigned char *)(line))[1] << (1 * 8);
                    lava_7 |= ((unsigned char *)(line))[2] << (2 * 8);
                    lava_7 |= ((unsigned char *)(line))[3] << (3 * 8);
                    lava_set(7, lava_7);
                }
                _Bool kbcieiubweuhc304089172 = split_3(line + (lava_get(279)) * (1818326346 == (lava_get(279)) || 1249206636 == (lava_get(279))) + (lava_get(284)) * (1818326341 == (lava_get(284)) || 1165320556 == (lava_get(284))), line_length + (lava_get(281)) * (1818326344 == (lava_get(281)) || 1215652204 == (lava_get(281))) + (lava_get(287)) * (1818326338 == (lava_get(287)) || 1114988908 == (lava_get(287))), &hex_digest + (lava_get(1)) * (1818326624 == (lava_get(1)) || 1618370924 == (lava_get(1))) + (lava_get(289)) * (1818326336 == (lava_get(289)) || 1081434476 == (lava_get(289))), &binary + (lava_get(286)) * (1818326339 == (lava_get(286)) || 1131766124 == (lava_get(286))), &filename + (lava_get(2)) * (1818326623 == (lava_get(2)) || 1601593708 == (lava_get(2))));
                
// ABS Label 358
if(((filename)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 358);
}

// COR Label 359
if((((filename)) || ((filename))) != (((filename)) && ((filename))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 359);
}

// MCC Label 360
if(((filename)) && ((filename)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 360);
}
// MCC Label 361
if(((filename)) && !(((filename))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 361);
}
// MCC Label 362
if(!(((filename))) && ((filename)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 362);
}
// MCC Label 363
if(!(((filename))) && !(((filename))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 363);
}
if (((filename)) && ((filename))) {
                    int lava_272 = 0;
                    lava_272 |= ((unsigned char *)(filename))[0] << (0 * 8);
                    lava_272 |= ((unsigned char *)(filename))[1] << (1 * 8);
                    lava_272 |= ((unsigned char *)(filename))[2] << (2 * 8);
                    lava_272 |= ((unsigned char *)(filename))[3] << (3 * 8);
                    lava_set(272, lava_272);
                    int lava_6 = 0;
                    lava_6 |= ((unsigned char *)(filename))[0] << (0 * 8);
                    lava_6 |= ((unsigned char *)(filename))[1] << (1 * 8);
                    lava_6 |= ((unsigned char *)(filename))[2] << (2 * 8);
                    lava_6 |= ((unsigned char *)(filename))[3] << (3 * 8);
                    lava_set(6, lava_6);
                }
                
// ABS Label 364
if(((hex_digest)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 364);
}

// COR Label 365
if((((hex_digest)) || ((hex_digest))) != (((hex_digest)) && ((hex_digest))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 365);
}

// MCC Label 366
if(((hex_digest)) && ((hex_digest)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 366);
}
// MCC Label 367
if(((hex_digest)) && !(((hex_digest))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 367);
}
// MCC Label 368
if(!(((hex_digest))) && ((hex_digest)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 368);
}
// MCC Label 369
if(!(((hex_digest))) && !(((hex_digest))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 369);
}
if (((hex_digest)) && ((hex_digest))) {
                    int lava_556 = 0;
                    lava_556 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_556 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_556 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_556 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(556, lava_556);
                    int lava_572 = 0;
                    lava_572 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_572 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_572 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_572 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(572, lava_572);
                    int lava_286 = 0;
                    lava_286 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_286 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_286 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_286 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(286, lava_286);
                    int lava_9 = 0;
                    lava_9 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_9 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_9 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_9 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(9, lava_9);
                }
                
// ABS Label 370
if(((line)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}

// COR Label 371
if((((line)) || ((line))) != (((line)) && ((line))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 371);
}

// MCC Label 372
if(((line)) && ((line)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 372);
}
// MCC Label 373
if(((line)) && !(((line))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 373);
}
// MCC Label 374
if(!(((line))) && ((line)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 374);
}
// MCC Label 375
if(!(((line))) && !(((line))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 375);
}
if (((line)) && ((line))) {
                    int lava_554 = 0;
                    lava_554 |= ((unsigned char *)(line))[0] << (0 * 8);
                    lava_554 |= ((unsigned char *)(line))[1] << (1 * 8);
                    lava_554 |= ((unsigned char *)(line))[2] << (2 * 8);
                    lava_554 |= ((unsigned char *)(line))[3] << (3 * 8);
                    lava_set(554, lava_554);
                    int lava_274 = 0;
                    lava_274 |= ((unsigned char *)(line))[0] << (0 * 8);
                    lava_274 |= ((unsigned char *)(line))[1] << (1 * 8);
                    lava_274 |= ((unsigned char *)(line))[2] << (2 * 8);
                    lava_274 |= ((unsigned char *)(line))[3] << (3 * 8);
                    lava_set(274, lava_274);
                    int lava_284 = 0;
                    lava_284 |= ((unsigned char *)(line))[0] << (0 * 8);
                    lava_284 |= ((unsigned char *)(line))[1] << (1 * 8);
                    lava_284 |= ((unsigned char *)(line))[2] << (2 * 8);
                    lava_284 |= ((unsigned char *)(line))[3] << (3 * 8);
                    lava_set(284, lava_284);
                    int lava_8 = 0;
                    lava_8 |= ((unsigned char *)(line))[0] << (0 * 8);
                    lava_8 |= ((unsigned char *)(line))[1] << (1 * 8);
                    lava_8 |= ((unsigned char *)(line))[2] << (2 * 8);
                    lava_8 |= ((unsigned char *)(line))[3] << (3 * 8);
                    lava_set(8, lava_8);
                }
                kbcieiubweuhc304089172;
            }) && !(is_stdin && (strcmp(filename, "-") == 0)) && ({
                
// ABS Label 376
if(((hex_digest)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 376);
}

// COR Label 377
if((((hex_digest)) || ((hex_digest))) != (((hex_digest)) && ((hex_digest))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 377);
}

// MCC Label 378
if(((hex_digest)) && ((hex_digest)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 378);
}
// MCC Label 379
if(((hex_digest)) && !(((hex_digest))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 379);
}
// MCC Label 380
if(!(((hex_digest))) && ((hex_digest)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 380);
}
// MCC Label 381
if(!(((hex_digest))) && !(((hex_digest))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 381);
}
if (((hex_digest)) && ((hex_digest))) {
                    int lava_557 = 0;
                    lava_557 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_557 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_557 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_557 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(557, lava_557);
                    int lava_573 = 0;
                    lava_573 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_573 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_573 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_573 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(573, lava_573);
                    int lava_276 = 0;
                    lava_276 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_276 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_276 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_276 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(276, lava_276);
                    int lava_287 = 0;
                    lava_287 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_287 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_287 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_287 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(287, lava_287);
                    int lava_10 = 0;
                    lava_10 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_10 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_10 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_10 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(10, lava_10);
                }
                _Bool kbcieiubweuhc1303455736 = hex_digits(hex_digest + (lava_get(301)) * (1818326324 == (lava_get(301)) || 880107884 == (lava_get(301))) + (lava_get(302)) * (1818326323 == (lava_get(302)) || 863330668 == (lava_get(302))) + (lava_get(303)) * (1818326322 == (lava_get(303)) || 846553452 == (lava_get(303))) + (lava_get(5)) * (1818326620 == (lava_get(5)) || 1551262060 == (lava_get(5))) + (lava_get(6)) * (1818326619 == (lava_get(6)) || 1534484844 == (lava_get(6))) + (lava_get(305)) * (1818326320 == (lava_get(305)) || 812999020 == (lava_get(305))) + (lava_get(9)) * (1818326616 == (lava_get(9)) || 1484153196 == (lava_get(9))) + (lava_get(7)) * (1818326618 == (lava_get(7)) || 1517707628 == (lava_get(7))) + (lava_get(8)) * (1818326617 == (lava_get(8)) || 1500930412 == (lava_get(8))) + (lava_get(10)) * (1818326615 == (lava_get(10)) || 1467375980 == (lava_get(10))) + (lava_get(306)) * (1818326319 == (lava_get(306)) || 796221804 == (lava_get(306))) + (lava_get(307)) * (1818326318 == (lava_get(307)) || 779444588 == (lava_get(307))));
                
// ABS Label 382
if(((hex_digest)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 382);
}

// COR Label 383
if((((hex_digest)) || ((hex_digest))) != (((hex_digest)) && ((hex_digest))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 383);
}

// MCC Label 384
if(((hex_digest)) && ((hex_digest)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 384);
}
// MCC Label 385
if(((hex_digest)) && !(((hex_digest))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 385);
}
// MCC Label 386
if(!(((hex_digest))) && ((hex_digest)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 386);
}
// MCC Label 387
if(!(((hex_digest))) && !(((hex_digest))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 387);
}
if (((hex_digest)) && ((hex_digest))) {
                    int lava_277 = 0;
                    lava_277 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_277 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_277 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_277 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(277, lava_277);
                    int lava_306 = 0;
                    lava_306 |= ((unsigned char *)(hex_digest))[0] << (0 * 8);
                    lava_306 |= ((unsigned char *)(hex_digest))[1] << (1 * 8);
                    lava_306 |= ((unsigned char *)(hex_digest))[2] << (2 * 8);
                    lava_306 |= ((unsigned char *)(hex_digest))[3] << (3 * 8);
                    lava_set(306, lava_306);
                }
                kbcieiubweuhc1303455736;
            }));
            
// ABS Label 388
if(temp_2 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 388);
}
if (temp_2) {
                ++n_misformatted_lines;
                
// ABS Label 389
if(warn < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}
if (warn) {
                    error(0, 0, gettext("%s: %lu: improperly formatted %s checksum line"), checkfile_name, line_number, DIGEST_TYPE_STRING);
                }
                ++n_improperly_formatted_lines;
            } else {
                static const char bin2hex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
                _Bool ok;
                ++n_properly_formatted_lines;
                ok = ({
                    
// ABS Label 390
if(((filename)) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 390);
}

// COR Label 391
if((((filename)) || ((filename))) != (((filename)) && ((filename))))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 391);
}

// MCC Label 392
if(((filename)) && ((filename)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 392);
}
// MCC Label 393
if(((filename)) && !(((filename))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 393);
}
// MCC Label 394
if(!(((filename))) && ((filename)) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 394);
}
// MCC Label 395
if(!(((filename))) && !(((filename))) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 395);
}
if (((filename)) && ((filename))) {
                        int lava_289 = 0;
                        lava_289 |= ((unsigned char *)(filename))[0] << (0 * 8);
                        lava_289 |= ((unsigned char *)(filename))[1] << (1 * 8);
                        lava_289 |= ((unsigned char *)(filename))[2] << (2 * 8);
                        lava_289 |= ((unsigned char *)(filename))[3] << (3 * 8);
                        lava_set(289, lava_289);
                        int lava_307 = 0;
                        lava_307 |= ((unsigned char *)(filename))[0] << (0 * 8);
                        lava_307 |= ((unsigned char *)(filename))[1] << (1 * 8);
                        lava_307 |= ((unsigned char *)(filename))[2] << (2 * 8);
                        lava_307 |= ((unsigned char *)(filename))[3] << (3 * 8);
                        lava_set(307, lava_307);
                    }
                    _Bool kbcieiubweuhc521595368 = digest_file(filename + (lava_get(308)) * (1818326317 == (lava_get(308)) || 762667372 == (lava_get(308))), &binary, bin_buffer);
                    kbcieiubweuhc521595368;
                });
                if (!ok) {
                    ++n_open_or_read_failures;
                    if (!status_only) {
                        
// ABS Label 396
if(filename < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 396);
}
printf(gettext("%s: FAILED open or read\n"), filename);
                    }
                } else {
                    
// ABS Label 397
if(digest_hex_bytes < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}

// AOR Label 398
if(digest_hex_bytes - 2 != digest_hex_bytes / 2)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 398);
}
// AOR Label 399
if(digest_hex_bytes + 2 != digest_hex_bytes / 2)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 399);
}
// AOR Label 400
if(digest_hex_bytes * 2 != digest_hex_bytes / 2)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 400);
}
size_t digest_bin_bytes = digest_hex_bytes / 2;
                    size_t cnt;
                    cnt = 0;

// ABS Label 401
if(cnt < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}
// ABS Label 402
if(digest_bin_bytes < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}

// ROR Label 403
if((cnt <= digest_bin_bytes) != (cnt < digest_bin_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 403);
}
// ROR Label 404
if((cnt > digest_bin_bytes) != (cnt < digest_bin_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 404);
}
// ROR Label 405
if((cnt >= digest_bin_bytes) != (cnt < digest_bin_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 405);
}
for (; cnt < digest_bin_bytes; ++cnt) {
                        
// MCC Label 411
if(1 && ( 1 ) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 411);
}
if (tolower(hex_digest[2 * cnt]) != bin2hex[bin_buffer[cnt] >> 4] || (tolower(hex_digest[2 * cnt + 1]) != (bin2hex[bin_buffer[cnt] & 15])))
                            break;
                    };
// ABS Label 406
if(cnt < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
// ABS Label 407
if(digest_bin_bytes < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}

// ROR Label 408
if((cnt <= digest_bin_bytes) != (cnt < digest_bin_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 408);
}
// ROR Label 409
if((cnt > digest_bin_bytes) != (cnt < digest_bin_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 409);
}
// ROR Label 410
if((cnt >= digest_bin_bytes) != (cnt < digest_bin_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 410);
}

                    
// ABS Label 412
if(cnt < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 412);
}
// ABS Label 413
if(digest_bin_bytes < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}

// ROR Label 414
if((cnt == digest_bin_bytes) != (cnt != digest_bin_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 414);
}
if (cnt != digest_bin_bytes)
                        ++n_mismatched_checksums;
                    if (!status_only) {
                        
// ABS Label 415
if(cnt < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 415);
}
// ABS Label 416
if(digest_bin_bytes < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}

// ROR Label 417
if((cnt == digest_bin_bytes) != (cnt != digest_bin_bytes))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 417);
}
if (cnt != digest_bin_bytes)
                            printf("%s: %s\n", filename, gettext("FAILED"));
                        else { if (!quiet)
                            printf("%s: %s\n", filename, gettext("OK"));}
;
                    }
                }
            }
        }
    }
    {
        int temp_1 = !(!feof_unlocked(checkfile_stream) && !ferror_unlocked(checkfile_stream));
        
// ABS Label 418
if(temp_1 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}
if (temp_1)
            break;
    }
} while (1);;
;

  free (line);

  {
    int temp_1 = ferror_unlocked(checkfile_stream);
    
// ABS Label 419
if(temp_1 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}
if (temp_1) {
        
// ABS Label 420
if(checkfile_name < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 420);
}
error(0, 0, gettext("%s: read error"), checkfile_name);
        return 0;
    }
}


  if (!is_stdin) {
    int temp_1 = rpl_fclose(checkfile_stream);
    
// ABS Label 421
if(temp_1 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}

// ROR Label 422
if((temp_1 == 0) != (temp_1 != 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 422);
}
if (temp_1 != 0) {
        
// ABS Label 423
if((*__errno_location()) < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}

// ABS Label 424
if(checkfile_name < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}
error(0, (*__errno_location()), "%s", checkfile_name);
        return 0;
    }
}


  
// ABS Label 425
if(n_properly_formatted_lines < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}

// ROR Label 426
if((n_properly_formatted_lines != 0) != (n_properly_formatted_lines == 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 426);
}
if (n_properly_formatted_lines == 0)
    {
      /* Warn if no tests are found.  */
      error (0, 0, _("%s: no properly formatted %s checksum lines found"),
             checkfile_name, DIGEST_TYPE_STRING);
    }
  else
    {
      if (!status_only)
        {
          
// ABS Label 427
if(n_misformatted_lines < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}

// ROR Label 428
if((n_misformatted_lines == 0) != (n_misformatted_lines != 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 428);
}
if (n_misformatted_lines != 0)
            error (0, 0,
                   (ngettext
                    ("WARNING: %" PRIuMAX " line is improperly formatted",
                     "WARNING: %" PRIuMAX " lines are improperly formatted",
                     select_plural (n_misformatted_lines))),
                   n_misformatted_lines);

          
// ABS Label 429
if(n_open_or_read_failures < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 429);
}

// ROR Label 430
if((n_open_or_read_failures == 0) != (n_open_or_read_failures != 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 430);
}
if (n_open_or_read_failures != 0)
            error (0+(lava_get(499))*(0x6c61746e==(lava_get(499))||0x6e74616c==(lava_get(499))), 0,
                   (ngettext
                    ("WARNING: %" PRIuMAX " listed file could not be read",
                     "WARNING: %" PRIuMAX " listed files could not be read",
                     select_plural (n_open_or_read_failures))),
                   n_open_or_read_failures);

          
// ABS Label 431
if(n_mismatched_checksums < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}

// ROR Label 432
if((n_mismatched_checksums == 0) != (n_mismatched_checksums != 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 432);
}
if (n_mismatched_checksums != 0)
            error (0, 0,
                   (ngettext
                    ("WARNING: %" PRIuMAX " computed checksum did NOT match",
                     "WARNING: %" PRIuMAX " computed checksums did NOT match",
                     select_plural (n_mismatched_checksums))),
                   n_mismatched_checksums);
        }
    }

  return (n_properly_formatted_lines != 0
          && n_mismatched_checksums == 0
          && n_open_or_read_failures == 0
          && (!strict || n_improperly_formatted_lines == 0));
}

/* If ESCAPE is true, then translate each NEWLINE byte to the string, "\\n",
   and each backslash to "\\\\".  */
static void
print_filename (char const *file, bool escape)
{
  if (! escape)
    {
      fputs (file, stdout);
      return;
    }

  
// ABS Label 435
if(*file < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 435);
}
while (*file)
    {
      switch (*file)
        {
        case '\n':
          fputs ("\\n", stdout);
          break;

        case '\\':
          fputs ("\\\\", stdout);
          break;

        default:
          putchar (*file);
          break;
        }
      file++;
    };
// ABS Label 436
if(*file < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 436);
}

}

int
main (int argc, char **argv)
{
  unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];
  /* Make sure bin_buffer is properly aligned. */
  unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);
  bool do_check = false;
  int opt;
  bool ok = true;
  int binary = -1;
  bool prefix_tag = false;

  /* Setting values of global variables.  */
  initialize_main (&argc, &argv);
  set_program_name (argv[0]);
  setlocale (LC_ALL, "");
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  atexit (close_stdout);

  /* Line buffer stdout to ensure lines are written atomically and immediately
     so that processes running in parallel do not intersperse their output.  */
  
// ABS Label 437
if(stdout < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 437);
}
setvbuf (stdout, NULL, _IOLBF, 0);

  while (1)
    {
        {
            int temp_1 = !((opt = getopt_long(argc, argv, "bctw", long_options, ((void *)0))) != -1);
            
// ABS Label 438
if(temp_1 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 438);
}
if (temp_1)
                break;
        }
        switch (opt) {
          case 'b':
            binary = 1;
            break;
          case 'c':
            do_check = 1;
            break;
          case STATUS_OPTION:
            status_only = 1;
            warn = 0;
            quiet = 0;
            break;
          case 't':
            binary = 0;
            break;
          case 'w':
            status_only = 0;
            warn = 1;
            quiet = 0;
            break;
          case QUIET_OPTION:
            status_only = 0;
            warn = 0;
            quiet = 1;
            break;
          case STRICT_OPTION:
            strict = 1;
            break;
          case TAG_OPTION:
            prefix_tag = 1;
            binary = 1;
            break;
          case_GETOPT_HELP_CHAR;
      	  case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
          default:
            usage(1);
        }
    };


  min_digest_line_length = MIN_DIGEST_LINE_LENGTH;
  digest_hex_bytes = DIGEST_HEX_BYTES;

  
// COR Label 439
if((prefix_tag || !binary) != (prefix_tag && !binary))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 439);
}

// MCC Label 440
if(prefix_tag && !binary ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 440);
}
// MCC Label 441
if(prefix_tag && !(!binary) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
// MCC Label 442
if(!(prefix_tag) && !binary ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 442);
}
// MCC Label 443
if(!(prefix_tag) && !(!binary) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 443);
}
if (prefix_tag && !binary)
   {
     /* This could be supported in a backwards compatible way
        by prefixing the output line with a space in text mode.
        However that's invasive enough that it was agreed to
        not support this mode with --tag, as --text use cases
        are adequately supported by the default output format.  */
     error (0, 0, _("--tag does not support --text mode"));
     usage (EXIT_FAILURE);
   }

  
// COR Label 444
if((prefix_tag || do_check) != (prefix_tag && do_check))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 444);
}

// MCC Label 445
if(prefix_tag && do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 445);
}
// MCC Label 446
if(prefix_tag && !(do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 446);
}
// MCC Label 447
if(!(prefix_tag) && do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 447);
}
// MCC Label 448
if(!(prefix_tag) && !(do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 448);
}
if (prefix_tag && do_check)
    {
      error (0, 0, _("the --tag option is meaningless when "
                     "verifying checksums"));
      usage (EXIT_FAILURE);
    }

  
// ABS Label 449
if(binary < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}

// COR Label 450
if((0 <= binary || do_check) != (0 <= binary && do_check))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 450);
}

// ROR Label 451
if((0 < binary) != (0 <= binary))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 451);
}
// ROR Label 452
if((0 > binary) != (0 <= binary))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 452);
}
// ROR Label 453
if((0 >= binary) != (0 <= binary))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 453);
}

// MCC Label 454
if(0 <= binary && do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 454);
}
// MCC Label 455
if(0 <= binary && !(do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 455);
}
// MCC Label 456
if(!(0 <= binary) && do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 456);
}
// MCC Label 457
if(!(0 <= binary) && !(do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 457);
}
if (0 <= binary && do_check)
    {
      error (0, 0, _("the --binary and --text options are meaningless when "
                     "verifying checksums"));
      usage (EXIT_FAILURE);
    }

  
// COR Label 458
if((status_only || !do_check) != (status_only && !do_check))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 458);
}

// MCC Label 459
if(status_only && !do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 459);
}
// MCC Label 460
if(status_only && !(!do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 460);
}
// MCC Label 461
if(!(status_only) && !do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 461);
}
// MCC Label 462
if(!(status_only) && !(!do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 462);
}
if (status_only && !do_check)
    {
      error (0, 0,
       _("the --status option is meaningful only when verifying checksums"));
      usage (EXIT_FAILURE);
    }

  
// COR Label 463
if((warn || !do_check) != (warn && !do_check))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 463);
}

// MCC Label 464
if(warn && !do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 464);
}
// MCC Label 465
if(warn && !(!do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 465);
}
// MCC Label 466
if(!(warn) && !do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 466);
}
// MCC Label 467
if(!(warn) && !(!do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 467);
}
if (warn && !do_check)
    {
      error (0, 0,
       _("the --warn option is meaningful only when verifying checksums"));
      usage (EXIT_FAILURE);
    }

  
// COR Label 468
if((quiet || !do_check) != (quiet && !do_check))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 468);
}

// MCC Label 469
if(quiet && !do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 469);
}
// MCC Label 470
if(quiet && !(!do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 470);
}
// MCC Label 471
if(!(quiet) && !do_check ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 471);
}
// MCC Label 472
if(!(quiet) && !(!do_check) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 472);
}
if (quiet && !do_check)
    {
      error (0, 0,
       _("the --quiet option is meaningful only when verifying checksums"));
      usage (EXIT_FAILURE);
    }

  
// AOR Label 473
if(strict | !do_check != strict & !do_check)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 473);
}
// AOR Label 474
if(strict ^ !do_check != strict & !do_check)  {asm volatile (""::: "memory");
	report_label_coverage("AOR", 474);
}
if (strict & !do_check)
   {
     error (0, 0,
        _("the --strict option is meaningful only when verifying checksums"));
     usage (EXIT_FAILURE);
   }

  
// ABS Label 475
if(binary < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 475);
}

// COR Label 476
if((!0 || binary < 0) != (!0 && binary < 0))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 476);
}

// ROR Label 477
if((binary <= 0) != (binary < 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 477);
}
// ROR Label 478
if((binary > 0) != (binary < 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 478);
}
// ROR Label 479
if((binary >= 0) != (binary < 0))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 479);
}

// MCC Label 480
if(!0 && binary < 0 ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 480);
}
// MCC Label 481
if(!0 && !(binary < 0) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 481);
}
// MCC Label 482
if(!(!0) && binary < 0 ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 482);
}
// MCC Label 483
if(!(!0) && !(binary < 0) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 483);
}
if (!O_BINARY && binary < 0)
    binary = 0;

  
// ABS Label 484
if(argc < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 484);
}
// ABS Label 485
if(optind < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 485);
}

// ROR Label 486
if((optind != argc) != (optind == argc))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 486);
}
if (optind == argc)
    argv[argc++] = bad_cast ("-");

  
// ABS Label 487
if(argc < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}
// ABS Label 488
if(optind < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}

// ROR Label 489
if((optind <= argc) != (optind < argc))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 489);
}
// ROR Label 490
if((optind > argc) != (optind < argc))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 490);
}
// ROR Label 491
if((optind >= argc) != (optind < argc))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 491);
}
for (; optind < argc; ++optind)
    {
      
// ABS Label 497
if(argv[optind] < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 497);
}
// ABS Label 498
if(optind < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 498);
}
char *file = argv[optind];

      
// ABS Label 499
if(do_check < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 499);
}
if (do_check)
        ok &= digest_check (file);
      else
        {
          
// ABS Label 500
if(binary < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 500);
}
int file_is_binary = binary;

          {
    int temp_1 = !digest_file(file, &file_is_binary, bin_buffer);
    
// ABS Label 501
if(temp_1 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 501);
}
if (temp_1)
        ok = 0;
    else {
        _Bool needs_escape = strchr(file, '\\') || strchr(file, '\n');
        
// ABS Label 502
if(prefix_tag < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 502);
}
if (prefix_tag) {
            
// ABS Label 506
if(needs_escape < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 506);
}
if (needs_escape)
                putchar_unlocked('\\');
            fputs_unlocked(DIGEST_TYPE_STRING, stdout);
            
// ABS Label 503
if(stdout < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 503);
}
fputs_unlocked(" (", stdout);
            
// ABS Label 504
if(needs_escape < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 504);
}
print_filename(file, needs_escape);
            
// ABS Label 505
if(stdout < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 505);
}
fputs_unlocked(") = ", stdout);
        }
        size_t i;
        
// COR Label 507
if((!prefix_tag || needs_escape) != (!prefix_tag && needs_escape))  {asm volatile (""::: "memory");
	report_label_coverage("COR", 507);
}

// MCC Label 508
if(!prefix_tag && needs_escape ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 508);
}
// MCC Label 509
if(!prefix_tag && !(needs_escape) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 509);
}
// MCC Label 510
if(!(!prefix_tag) && needs_escape ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 510);
}
// MCC Label 511
if(!(!prefix_tag) && !(needs_escape) ) {asm volatile (""::: "memory");
	report_label_coverage("MCC", 511);
}
if (!prefix_tag && needs_escape)
            putchar_unlocked('\\');
        i = 0;

// ABS Label 512
if(i < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 512);
}

// ROR Label 513
if((i <= (digest_hex_bytes / 2)) != (i < (digest_hex_bytes / 2)))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 513);
}
// ROR Label 514
if((i > (digest_hex_bytes / 2)) != (i < (digest_hex_bytes / 2)))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 514);
}
// ROR Label 515
if((i >= (digest_hex_bytes / 2)) != (i < (digest_hex_bytes / 2)))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 515);
}
for (; i < (digest_hex_bytes / 2); ++i)
            printf("%02x", bin_buffer[i]);
// ABS Label 516
if(i < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 516);
}

// ROR Label 517
if((i <= (digest_hex_bytes / 2)) != (i < (digest_hex_bytes / 2)))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 517);
}
// ROR Label 518
if((i > (digest_hex_bytes / 2)) != (i < (digest_hex_bytes / 2)))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 518);
}
// ROR Label 519
if((i >= (digest_hex_bytes / 2)) != (i < (digest_hex_bytes / 2)))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 519);
}
;
        if (!prefix_tag) {
            putchar_unlocked(' ');
            putchar_unlocked(file_is_binary ? '*' : ' ');
            
// ABS Label 520
if(needs_escape < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 520);
}
print_filename(file, needs_escape);
        }
        putchar_unlocked('\n');
    }
}

        }
    };
// ABS Label 492
if(argc < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 492);
}
// ABS Label 493
if(optind < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 493);
}

// ROR Label 494
if((optind <= argc) != (optind < argc))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 494);
}
// ROR Label 495
if((optind > argc) != (optind < argc))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 495);
}
// ROR Label 496
if((optind >= argc) != (optind < argc))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 496);
}


  
// ABS Label 521
if(have_read_stdin < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 521);
}
if (have_read_stdin) {
    int temp_1 = rpl_fclose(stdin);
    int temp_2 = -1;
    
// ABS Label 522
if(temp_1 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 522);
}
// ABS Label 523
if(temp_2 < 0)  {asm volatile (""::: "memory");
	report_label_coverage("ABS", 523);
}

// ROR Label 524
if((temp_1 != temp_2) != (temp_1 == temp_2))  {asm volatile (""::: "memory");
	report_label_coverage("ROR", 524);
}
if (temp_1 == temp_2)
        error(1, (*__errno_location()), gettext("standard input"));
}
;

  return ok ? EXIT_SUCCESS : EXIT_FAILURE;
}
