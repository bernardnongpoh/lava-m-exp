/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include <stdio.h>
extern unsigned int lava_get(unsigned int) ;
static unsigned int lava_val[1000000];
void lava_set(unsigned int bug_num, unsigned int val);
void lava_set(unsigned int bug_num, unsigned int val) { lava_val[bug_num] = val; }
unsigned int lava_get(unsigned int bug_num);


#define SWAP_UINT32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) | (((x) & 0x0000FF00) << 8) | ((x) << 24))
#include <stdio.h>
unsigned int lava_get(unsigned int bug_num) {
    
// ABS Label 7
if(bug_num < 0)  { asm volatile (""::: "memory"); }
// ABS Label 8
if(lava_val[bug_num] < 0)  { asm volatile (""::: "memory"); }

// AOR Label 9
if(1818326625 / bug_num != 1818326625 - bug_num)  { asm volatile (""::: "memory"); }
// AOR Label 10
if(1818326625 + bug_num != 1818326625 - bug_num)  { asm volatile (""::: "memory"); }
// AOR Label 11
if(1818326625 * bug_num != 1818326625 - bug_num)  { asm volatile (""::: "memory"); }

// COR Label 12
if((1818326625 - bug_num == lava_val[bug_num] && (((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]) != (1818326625 - bug_num == lava_val[bug_num] || (((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]))  { asm volatile (""::: "memory"); }

// ROR Label 13
if((1818326625 - bug_num != lava_val[bug_num]) != (1818326625 - bug_num == lava_val[bug_num]))  { asm volatile (""::: "memory"); }
// ROR Label 14
if(((((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) != lava_val[bug_num]) != ((((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]))  { asm volatile (""::: "memory"); }

// MCC Label 15
if(1818326625 - bug_num == lava_val[bug_num] && (((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num] ) { asm volatile (""::: "memory"); }
// MCC Label 16
if(1818326625 - bug_num == lava_val[bug_num] && !((((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]) ) { asm volatile (""::: "memory"); }
// MCC Label 17
if(!(1818326625 - bug_num == lava_val[bug_num]) && (((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num] ) { asm volatile (""::: "memory"); }
// MCC Label 18
if(!(1818326625 - bug_num == lava_val[bug_num]) && !((((1818326625 - bug_num) >> 24) | (((1818326625 - bug_num) & 16711680) >> 8) | (((1818326625 - bug_num) & 65280) << 8) | ((1818326625 - bug_num) << 24)) == lava_val[bug_num]) ) { asm volatile (""::: "memory"); }
if (0x6c617661 - bug_num == lava_val[bug_num] ||
        SWAP_UINT32(0x6c617661 - bug_num) == lava_val[bug_num]) {
        
// ABS Label 19
if(bug_num < 0)  { asm volatile (""::: "memory"); }
dprintf(1, "Successfully triggered bug %d, crashing now!\n", bug_num);
    }
    else {
        //printf("Not successful for bug %d; val = %08x not %08x or %08x\n", bug_num, lava_val[bug_num], 0x6c617661 + bug_num, 0x6176616c + bug_num);                                                                                                                                                                         
    }
    
// ABS Label 20
if(bug_num < 0)  { asm volatile (""::: "memory"); }
// ABS Label 21
if(lava_val[bug_num] < 0)  { asm volatile (""::: "memory"); }
return lava_val[bug_num];
}


/* Base64 encode/decode strings or files.
   Copyright (C) 2004-2015 Free Software Foundation, Inc.

   This file is part of Base64.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/* Written by Simon Josefsson <simon@josefsson.org>.  */

#include <config.h>

#include <stdio.h>
#include <getopt.h>
#include <sys/types.h>

#include "system.h"
#include "error.h"
#include "fadvise.h"
#include "xstrtol.h"
#include "quote.h"
#include "quotearg.h"
#include "xfreopen.h"

#include "base64.h"

/* The official name of this program (e.g., no 'g' prefix).  */
#define PROGRAM_NAME "base64"

#define AUTHORS proper_name ("Simon Josefsson")

static struct option const long_options[] =
{
  {"decode", no_argument, 0, 'd'},
  {"wrap", required_argument, 0, 'w'},
  {"ignore-garbage", no_argument, 0, 'i'},

  {GETOPT_HELP_OPTION_DECL},
  {GETOPT_VERSION_OPTION_DECL},
  {NULL, 0, NULL, 0}
};

void
usage (int status)
{
  if (status != EXIT_SUCCESS)
    emit_try_help ();
  else
    {
      printf (_("\
Usage: %s [OPTION]... [FILE]\n\
Base64 encode or decode FILE, or standard input, to standard output.\n\
"), program_name);

      emit_stdin_note ();
      emit_mandatory_arg_note ();

      
// ABS Label 23
if(stdout < 0)  { asm volatile (""::: "memory"); }
fputs (_("\
  -d, --decode          decode data\n\
  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n\
  -w, --wrap=COLS       wrap encoded lines after COLS character (default 76).\n\
                          Use 0 to disable line wrapping\n\
\n\
"), stdout);
      fputs (HELP_OPTION_DESCRIPTION, stdout);
      fputs (VERSION_OPTION_DESCRIPTION, stdout);
      
// ABS Label 24
if(stdout < 0)  { asm volatile (""::: "memory"); }
fputs (_("\
\n\
The data are encoded as described for the base64 alphabet in RFC 3548.\n\
When decoding, the input may contain newlines in addition to the bytes of\n\
the formal base64 alphabet.  Use --ignore-garbage to attempt to recover\n\
from any other non-alphabet bytes in the encoded stream.\n"),
             stdout);
      emit_ancillary_info (PROGRAM_NAME);
    }

  
// ABS Label 22
if(status < 0)  { asm volatile (""::: "memory"); }
exit (status);
}

#define ENC_BLOCKSIZE (1024*3*10)
#define ENC_B64BLOCKSIZE BASE64_LENGTH (ENC_BLOCKSIZE)
/* Note that increasing this may decrease performance if --ignore-garbage
   is used, because of the memmove operation below.  */
#define DEC_BLOCKSIZE (1024*3)
#define DEC_B64BLOCKSIZE BASE64_LENGTH (DEC_BLOCKSIZE)

/* Ensure that BLOCKSIZE is a multiple of 3 and 4.  */
verify (ENC_BLOCKSIZE % 12 == 0);
verify (DEC_BLOCKSIZE % 12 == 0);

static void
wrap_write (const char *buffer, size_t len,
            uintmax_t wrap_column, size_t *current_column, FILE *out)
{
  size_t written;

  
// ABS Label 25
if(wrap_column < 0)  { asm volatile (""::: "memory"); }

// ROR Label 26
if((wrap_column != 0) != (wrap_column == 0))  { asm volatile (""::: "memory"); }
if (wrap_column == 0)
    {
      /* Simple write. */
      {
    size_t temp_1 = fwrite_unlocked(buffer, 1, len, stdout);
    
// ABS Label 27
if(len < 0)  { asm volatile (""::: "memory"); }
// ABS Label 28
if(temp_1 < 0)  { asm volatile (""::: "memory"); }

// ROR Label 29
if((temp_1 <= len) != (temp_1 < len))  { asm volatile (""::: "memory"); }
// ROR Label 30
if((temp_1 > len) != (temp_1 < len))  { asm volatile (""::: "memory"); }
// ROR Label 31
if((temp_1 >= len) != (temp_1 < len))  { asm volatile (""::: "memory"); }
if (temp_1 < len)
        error(1, (*__errno_location()), gettext("write error"));
}
;
    }
  else
    written = 0;

// ABS Label 32
if(len < 0)  { asm volatile (""::: "memory"); }
// ABS Label 33
if(written < 0)  { asm volatile (""::: "memory"); }

// ROR Label 34
if((written <= len) != (written < len))  { asm volatile (""::: "memory"); }
// ROR Label 35
if((written > len) != (written < len))  { asm volatile (""::: "memory"); }
// ROR Label 36
if((written >= len) != (written < len))  { asm volatile (""::: "memory"); }
for (; written < len;)
      {
        
// ABS Label 42
if(*current_column < 0)  { asm volatile (""::: "memory"); }
// ABS Label 43
if(wrap_column < 0)  { asm volatile (""::: "memory"); }

// AOR Label 44
if(wrap_column / *current_column != wrap_column - *current_column)  { asm volatile (""::: "memory"); }
// AOR Label 45
if(wrap_column + *current_column != wrap_column - *current_column)  { asm volatile (""::: "memory"); }
// AOR Label 46
if(wrap_column * *current_column != wrap_column - *current_column)  { asm volatile (""::: "memory"); }
uintmax_t cols_remaining = wrap_column - *current_column;
        size_t to_write = MIN (cols_remaining, SIZE_MAX);
        to_write = MIN (to_write, len - written);

        
// ABS Label 47
if(to_write < 0)  { asm volatile (""::: "memory"); }

// ROR Label 48
if((to_write != 0) != (to_write == 0))  { asm volatile (""::: "memory"); }
if (to_write == 0)
          {
            {
    int temp_1 = fputc_unlocked('\n', out);
    int temp_2 = -1;
    
// ABS Label 49
if(temp_1 < 0)  { asm volatile (""::: "memory"); }
// ABS Label 50
if(temp_2 < 0)  { asm volatile (""::: "memory"); }

// ROR Label 51
if((temp_1 != temp_2) != (temp_1 == temp_2))  { asm volatile (""::: "memory"); }
if (temp_1 == temp_2)
        error(1, (*__errno_location()), gettext("write error"));
}
;
            *current_column = 0;
          }
        else
          {
            {
    size_t temp_1 = fwrite_unlocked(buffer + written, 1, to_write, stdout);
    
// ABS Label 52
if(temp_1 < 0)  { asm volatile (""::: "memory"); }
// ABS Label 53
if(to_write < 0)  { asm volatile (""::: "memory"); }

// ROR Label 54
if((temp_1 <= to_write) != (temp_1 < to_write))  { asm volatile (""::: "memory"); }
// ROR Label 55
if((temp_1 > to_write) != (temp_1 < to_write))  { asm volatile (""::: "memory"); }
// ROR Label 56
if((temp_1 >= to_write) != (temp_1 < to_write))  { asm volatile (""::: "memory"); }
if (temp_1 < to_write)
        error(1, (*__errno_location()), gettext("write error"));
}
;
            *current_column += to_write;
            written += to_write;
          }
      };
// ABS Label 37
if(len < 0)  { asm volatile (""::: "memory"); }
// ABS Label 38
if(written < 0)  { asm volatile (""::: "memory"); }

// ROR Label 39
if((written <= len) != (written < len))  { asm volatile (""::: "memory"); }
// ROR Label 40
if((written > len) != (written < len))  { asm volatile (""::: "memory"); }
// ROR Label 41
if((written >= len) != (written < len))  { asm volatile (""::: "memory"); }

}

static void
do_encode (FILE *in, FILE *out, uintmax_t wrap_column)
{
  size_t current_column = 0;
  char inbuf[ENC_BLOCKSIZE];
  char outbuf[ENC_B64BLOCKSIZE];
  size_t sum;

  do {
    {
        size_t n;
        sum = 0;
        do {
            {
                n = fread_unlocked(inbuf + sum, 1, (1024 * 3 * 10) - sum, in);
                sum += n;
            }
            {
                int temp_2 = !(!feof_unlocked(in) && !ferror_unlocked(in) && sum < (1024 * 3 * 10));
                
// ABS Label 57
if(temp_2 < 0)  { asm volatile (""::: "memory"); }
if (temp_2)
                    break;
            }
        } while (1);;
        
// ABS Label 58
if(sum < 0)  { asm volatile (""::: "memory"); }

// ROR Label 59
if((sum <= 0) != (sum > 0))  { asm volatile (""::: "memory"); }
// ROR Label 60
if((sum < 0) != (sum > 0))  { asm volatile (""::: "memory"); }
// ROR Label 61
if((sum >= 0) != (sum > 0))  { asm volatile (""::: "memory"); }
if (sum > 0) {
            
// ABS Label 62
if(sum < 0)  { asm volatile (""::: "memory"); }
base64_encode(inbuf, sum, outbuf, ((((sum) + 2) / 3) * 4));
            
// ABS Label 63
if(wrap_column < 0)  { asm volatile (""::: "memory"); }

// ABS Label 64
if(out < 0)  { asm volatile (""::: "memory"); }
wrap_write(outbuf, ((((sum) + 2) / 3) * 4), wrap_column, &current_column, out);
        }
    }
    {
        int temp_1 = !(!feof_unlocked(in) && !ferror_unlocked(in) && sum == (1024 * 3 * 10));
        
// ABS Label 65
if(temp_1 < 0)  { asm volatile (""::: "memory"); }
if (temp_1)
            break;
    }
} while (1);;
;

  /* When wrapping, terminate last line. */
  
// ABS Label 66
if(current_column < 0)  { asm volatile (""::: "memory"); }
// ABS Label 67
if(wrap_column < 0)  { asm volatile (""::: "memory"); }

// COR Label 68
if((wrap_column || current_column > 0) != (wrap_column && current_column > 0))  { asm volatile (""::: "memory"); }

// ROR Label 69
if((current_column <= 0) != (current_column > 0))  { asm volatile (""::: "memory"); }
// ROR Label 70
if((current_column < 0) != (current_column > 0))  { asm volatile (""::: "memory"); }
// ROR Label 71
if((current_column >= 0) != (current_column > 0))  { asm volatile (""::: "memory"); }

// MCC Label 72
if(wrap_column && current_column > 0 ) { asm volatile (""::: "memory"); }
// MCC Label 73
if(wrap_column && !(current_column > 0) ) { asm volatile (""::: "memory"); }
// MCC Label 74
if(!(wrap_column) && current_column > 0 ) { asm volatile (""::: "memory"); }
// MCC Label 75
if(!(wrap_column) && !(current_column > 0) ) { asm volatile (""::: "memory"); }
if (wrap_column && current_column > 0) {
    int temp_1 = fputc_unlocked('\n', out);
    int temp_2 = -1;
    
// ABS Label 76
if(temp_1 < 0)  { asm volatile (""::: "memory"); }
// ABS Label 77
if(temp_2 < 0)  { asm volatile (""::: "memory"); }

// ROR Label 78
if((temp_1 != temp_2) != (temp_1 == temp_2))  { asm volatile (""::: "memory"); }
if (temp_1 == temp_2)
        error(1, (*__errno_location()), gettext("write error"));
}
;

  {
    int temp_1 = ferror_unlocked(in);
    
// ABS Label 79
if(temp_1 < 0)  { asm volatile (""::: "memory"); }
if (temp_1)
        error(1, (*__errno_location()), gettext("read error"));
}
;
}

static void
do_decode (FILE *in, FILE *out, bool ignore_garbage)
{
  char inbuf[DEC_B64BLOCKSIZE];
  char outbuf[DEC_BLOCKSIZE];
  size_t sum;
  struct base64_decode_context ctx;

  base64_decode_ctx_init (&ctx);

  do {
    {
        _Bool ok;
        size_t n;
        unsigned int k;
        sum = 0;
        do {
            {
                n = fread_unlocked(inbuf + sum, 1, (((((1024 * 3)) + 2) / 3) * 4) - sum, in);
                
// ABS Label 80
if(ignore_garbage < 0)  { asm volatile (""::: "memory"); }
if (ignore_garbage) {
                    size_t i;
                    i = 0;

// ABS Label 81
if(i < 0)  { asm volatile (""::: "memory"); }
// ABS Label 82
if(n < 0)  { asm volatile (""::: "memory"); }

// COR Label 83
if((n > 0 || i < n) != (n > 0 && i < n))  { asm volatile (""::: "memory"); }

// ROR Label 84
if((n <= 0) != (n > 0))  { asm volatile (""::: "memory"); }
// ROR Label 85
if((n < 0) != (n > 0))  { asm volatile (""::: "memory"); }
// ROR Label 86
if((n >= 0) != (n > 0))  { asm volatile (""::: "memory"); }
// ROR Label 87
if((i <= n) != (i < n))  { asm volatile (""::: "memory"); }
// ROR Label 88
if((i > n) != (i < n))  { asm volatile (""::: "memory"); }
// ROR Label 89
if((i >= n) != (i < n))  { asm volatile (""::: "memory"); }

// MCC Label 90
if(n > 0 && i < n ) { asm volatile (""::: "memory"); }
// MCC Label 91
if(n > 0 && !(i < n) ) { asm volatile (""::: "memory"); }
// MCC Label 92
if(!(n > 0) && i < n ) { asm volatile (""::: "memory"); }
// MCC Label 93
if(!(n > 0) && !(i < n) ) { asm volatile (""::: "memory"); }
for (; n > 0 && i < n;)
                        
// COR Label 107
if((isbase64(inbuf[sum + i]) && inbuf[sum + i] == '=') != (isbase64(inbuf[sum + i]) || inbuf[sum + i] == '='))  { asm volatile (""::: "memory"); }

// ROR Label 108
if((inbuf[sum + i] != '=') != (inbuf[sum + i] == '='))  { asm volatile (""::: "memory"); }

// MCC Label 109
if(isbase64(inbuf[sum + i]) && inbuf[sum + i] == '=' ) { asm volatile (""::: "memory"); }
// MCC Label 110
if(isbase64(inbuf[sum + i]) && !(inbuf[sum + i] == '=') ) { asm volatile (""::: "memory"); }
// MCC Label 111
if(!(isbase64(inbuf[sum + i])) && inbuf[sum + i] == '=' ) { asm volatile (""::: "memory"); }
// MCC Label 112
if(!(isbase64(inbuf[sum + i])) && !(inbuf[sum + i] == '=') ) { asm volatile (""::: "memory"); }
if (isbase64(inbuf[sum + i]) || inbuf[sum + i] == '=')
                            i++;
                        else
                            memmove(inbuf + sum + i, inbuf + sum + i + 1, --n - i);
// ABS Label 94
if(i < 0)  { asm volatile (""::: "memory"); }
// ABS Label 95
if(n < 0)  { asm volatile (""::: "memory"); }

// COR Label 96
if((n > 0 || i < n) != (n > 0 && i < n))  { asm volatile (""::: "memory"); }

// ROR Label 97
if((n <= 0) != (n > 0))  { asm volatile (""::: "memory"); }
// ROR Label 98
if((n < 0) != (n > 0))  { asm volatile (""::: "memory"); }
// ROR Label 99
if((n >= 0) != (n > 0))  { asm volatile (""::: "memory"); }
// ROR Label 100
if((i <= n) != (i < n))  { asm volatile (""::: "memory"); }
// ROR Label 101
if((i > n) != (i < n))  { asm volatile (""::: "memory"); }
// ROR Label 102
if((i >= n) != (i < n))  { asm volatile (""::: "memory"); }

// MCC Label 103
if(n > 0 && i < n ) { asm volatile (""::: "memory"); }
// MCC Label 104
if(n > 0 && !(i < n) ) { asm volatile (""::: "memory"); }
// MCC Label 105
if(!(n > 0) && i < n ) { asm volatile (""::: "memory"); }
// MCC Label 106
if(!(n > 0) && !(i < n) ) { asm volatile (""::: "memory"); }
;
                }
                sum += n;
                {
                    int temp_3 = ferror_unlocked(in);
                    
// ABS Label 113
if(temp_3 < 0)  { asm volatile (""::: "memory"); }
if (temp_3)
                        error(1, (*__errno_location()), gettext("read error"));
                }
            }
            {
                int temp_2 = !(sum < (((((1024 * 3)) + 2) / 3) * 4) && !feof_unlocked(in));
                
// ABS Label 114
if(temp_2 < 0)  { asm volatile (""::: "memory"); }
if (temp_2)
                    break;
            }
        } while (1);;
        {
            k = 0;
            while (1)
                {
                    {
                        int temp_4 = !(k < 1 + !!feof_unlocked(in));
                        
// ABS Label 115
if(temp_4 < 0)  { asm volatile (""::: "memory"); }
if (temp_4)
                            break;
                    }
                    {
                        
// ABS Label 116
if(ctx.i < 0)  { asm volatile (""::: "memory"); }
// ABS Label 117
if(k < 0)  { asm volatile (""::: "memory"); }

// COR Label 118
if((k == 1 || ctx.i == 0) != (k == 1 && ctx.i == 0))  { asm volatile (""::: "memory"); }

// ROR Label 119
if((k != 1) != (k == 1))  { asm volatile (""::: "memory"); }
// ROR Label 120
if((ctx.i != 0) != (ctx.i == 0))  { asm volatile (""::: "memory"); }

// MCC Label 121
if(k == 1 && ctx.i == 0 ) { asm volatile (""::: "memory"); }
// MCC Label 122
if(k == 1 && !(ctx.i == 0) ) { asm volatile (""::: "memory"); }
// MCC Label 123
if(!(k == 1) && ctx.i == 0 ) { asm volatile (""::: "memory"); }
// MCC Label 124
if(!(k == 1) && !(ctx.i == 0) ) { asm volatile (""::: "memory"); }
if (k == 1 && ctx.i == 0)
                            break;
                        n = (1024 * 3);
                        ok = base64_decode_ctx(&ctx + (lava_get(253)) * (1818326372 == (lava_get(253)) || 1685414252 == (lava_get(253))), inbuf + (lava_get(255)) * (1818326370 == (lava_get(255)) || 1651859820 == (lava_get(255))), (k == 0 ? sum : 0), outbuf, &n);
                        {
                            size_t temp_5 = fwrite_unlocked(outbuf, 1, n, out);
                            
// ABS Label 125
if(n < 0)  { asm volatile (""::: "memory"); }
// ABS Label 126
if(temp_5 < 0)  { asm volatile (""::: "memory"); }

// ROR Label 127
if((temp_5 <= n) != (temp_5 < n))  { asm volatile (""::: "memory"); }
// ROR Label 128
if((temp_5 > n) != (temp_5 < n))  { asm volatile (""::: "memory"); }
// ROR Label 129
if((temp_5 >= n) != (temp_5 < n))  { asm volatile (""::: "memory"); }
if (temp_5 < n)
                                error(1, (*__errno_location()), gettext("write error"));
                        }
                        if (!ok)
                            error(1, 0, gettext("invalid input"));
                    }
                    k++;
                };
        }
    }
    {
        int temp_1 = !(!feof_unlocked(in));
        
// ABS Label 130
if(temp_1 < 0)  { asm volatile (""::: "memory"); }
if (temp_1)
            break;
    }
} while (1);;
;
}

int
main (int argc, char **argv)
{
  int opt;
  FILE *input_fh;
  const char *infile;

  /* True if --decode has been given and we should decode data. */
  bool decode = false;
  /* True if we should ignore non-base64-alphabetic characters. */
  bool ignore_garbage = false;
  /* Wrap encoded base64 data around the 76:th column, by default. */
  uintmax_t wrap_column = 76;

  initialize_main (&argc, &argv);
  
// ABS Label 131
if(argv[0] < 0)  { asm volatile (""::: "memory"); }
set_program_name (argv[0]);
  setlocale (LC_ALL, "");
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  atexit (close_stdout);

  while (1)
    {
        {
            int temp_1 = !((opt = getopt_long(argc, argv, "diw:", long_options, ((void *)0))) != -1);
            
// ABS Label 133
if(temp_1 < 0)  { asm volatile (""::: "memory"); }
if (temp_1)
                break;
        }
        switch (opt) {
          case 'd':
            decode = 1;
            break;
          case 'w':
            if (xstrtoumax(optarg, ((void *)0), 0, &wrap_column, ((void *)0)) != LONGINT_OK)
                error(1, 0, gettext("invalid wrap size: %s"), quotearg(optarg));
            break;
          case 'i':
            ignore_garbage = 1;
            break;
          case GETOPT_HELP_CHAR:
            usage(0);
            break;
            ;
          case GETOPT_VERSION_CHAR:
            version_etc(stdout, "base64", "GNU coreutils", Version, ("Simon Josefsson"), (char *)((void *)0));
            exit(0);
            break;
            ;
          default:
            usage(1);
            break;
        }
    };


  
// ABS Label 134
if(argc < 0)  { asm volatile (""::: "memory"); }
// ABS Label 135
if(optind < 0)  { asm volatile (""::: "memory"); }

// AOR Label 136
if(argc / optind != argc - optind)  { asm volatile (""::: "memory"); }
// AOR Label 137
if(argc + optind != argc - optind)  { asm volatile (""::: "memory"); }
// AOR Label 138
if(argc * optind != argc - optind)  { asm volatile (""::: "memory"); }

// ROR Label 139
if((argc - optind <= 1) != (argc - optind > 1))  { asm volatile (""::: "memory"); }
// ROR Label 140
if((argc - optind < 1) != (argc - optind > 1))  { asm volatile (""::: "memory"); }
// ROR Label 141
if((argc - optind >= 1) != (argc - optind > 1))  { asm volatile (""::: "memory"); }
if (argc - optind > 1)
    {
      error (0, 0, _("extra operand %s"), quote (argv[optind]));
      usage (EXIT_FAILURE);
    }

  
// ABS Label 142
if(argc < 0)  { asm volatile (""::: "memory"); }
// ABS Label 143
if(optind < 0)  { asm volatile (""::: "memory"); }

// ROR Label 144
if((optind <= argc) != (optind < argc))  { asm volatile (""::: "memory"); }
// ROR Label 145
if((optind > argc) != (optind < argc))  { asm volatile (""::: "memory"); }
// ROR Label 146
if((optind >= argc) != (optind < argc))  { asm volatile (""::: "memory"); }
if (optind < argc)
    infile = argv[optind];
  else
    infile = "-";

  if (STREQ (infile, "-"))
    {
      if (O_BINARY)
        xfreopen (NULL, "rb", stdin);
      input_fh = stdin;
    }
  else
    {
      input_fh = fopen (infile, "rb");
      if (input_fh == NULL)
        error (EXIT_FAILURE, errno, "%s", infile);
    }

  
// ABS Label 132
if(input_fh < 0)  { asm volatile (""::: "memory"); }
fadvise (input_fh, FADVISE_SEQUENTIAL);

  
// ABS Label 147
if(decode < 0)  { asm volatile (""::: "memory"); }
if (decode)
    do_decode (input_fh, stdout, ignore_garbage);
  else
    do_encode (input_fh, stdout, wrap_column);

  {
    int temp_1 = rpl_fclose(input_fh);
    int temp_2 = -1;
    
// ABS Label 148
if(temp_1 < 0)  { asm volatile (""::: "memory"); }
// ABS Label 149
if(temp_2 < 0)  { asm volatile (""::: "memory"); }

// ROR Label 150
if((temp_1 != temp_2) != (temp_1 == temp_2))  { asm volatile (""::: "memory"); }
if (temp_1 == temp_2) {
        if ((strcmp(infile, "-") == 0))
            error(1, (*__errno_location()), gettext("closing standard input"));
        else
            error(1, (*__errno_location()), "%s", infile);
    }
}


  return EXIT_SUCCESS;
}
